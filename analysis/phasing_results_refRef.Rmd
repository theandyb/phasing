---
title: "phasing_results_refRef"
author: "Andy Beck"
date: "2024-03-08"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

## Libraries and Utility Functions

```{r}
library(tidyverse)
library(janitor)
library(reactable)
library(gtsummary)
library(corrr)
source("code/common_functions.R")

cbbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
```

```{r}
# function takes dataframe and two column names, returns a scatterplot
scatterplot <- function(df, x_var, y_var, colour_var, xlab, ylab){
  ggplot(df) +
    geom_point(aes(.data[[x_var]], .data[[y_var]], color = .data[[colour_var]])) +
    labs(x = xlab, y = ylab) +
    theme_classic() + 
    geom_abline(slope = 1, intercept = 0) + 
    scale_color_manual(values=cbbPalette)
}
```


## Directories

```{r}
eagle_switch_dir <-   "/net/snowwhite/home/beckandy/research/phasing/output/switch_errors/switch_errors/eagle/annotated/"
shapeit_switch_dir <- "/net/snowwhite/home/beckandy/research/phasing/output/switch_errors/switch_errors/shapeit/annotated/"
beagle_switch_dir <-  "/net/snowwhite/home/beckandy/research/phasing/output/switch_errors/switch_errors/beagle/annotated/"
num_sites_dir <-      "/net/snowwhite/home/beckandy/research/phasing/output/switch_errors/vcf_n_sites/"
whatshap_dir <-       "/net/snowwhite/home/beckandy/research/phasing/output/switch_errors/whatshap/"
het_loc_dir <-        "/net/snowwhite/home/beckandy/research/phasing/output/switch_errors/het_loc/"
```

## Load Data

```{r}
gc_content_1kb <- read_tsv("data/ref/gc1kb_X_only.bed")
colnames(gc_content_1kb) <- c("CHR", "START", "END", "AT", "GC", "A", "C", "G", "T", "TOTAL", "OTHER", "LENGTH")
gc_content_1kb  <- gc_content_1kb %>%
  mutate(bin_id = (START / 1000) + 1)

df_vcftools <- lapply(c(1:700), 
                    function(x){
                      switch_summary(x, eagle_switch_dir, beagle_switch_dir, shapeit_switch_dir, gc_content_1kb, het_loc_dir)
                      }) %>%
  bind_rows()

df_vcftools$pop <- c(rep("EUR", 200), rep("AFR", 200), rep("AMR", 100), rep("EAS", 100), rep("SAS", 100))

df_wh_eagle <- get_all_whatshap("eagle", n = 700, pop = c(rep("EUR", 200), rep("AFR", 200), rep("AMR", 100), rep("EAS", 100), rep("SAS", 100)))
df_wh_beagle <- get_all_whatshap("beagle", n = 700, pop = c(rep("EUR", 200), rep("AFR", 200), rep("AMR", 100), rep("EAS", 100), rep("SAS", 100)))
df_wh_si <- get_all_whatshap("shapeit", n = 700, pop = c(rep("EUR", 200), rep("AFR", 200), rep("AMR", 100), rep("EAS", 100), rep("SAS", 100)))

# pd_size <- data.frame(id = 1:700, size = rep(0, 700))
# for(i in 1:700){
#   df_het <- read_tsv(paste0(het_loc_dir, "pair_",i,"_het_loc.txt"), col_names = c("chr", "pos", "gt", "X"),show_col_types = FALSE)
#   min_pos <- df_het$pos[1]
#   max_pos <- df_het$pos[length(df_het$pos)]
#   n_pos <- max_pos - min_pos
#   pd_size$size[i] <- n_pos
# }
# write_csv(pd_size, "/net/snowwhite/home/beckandy/research/phasing/output/switch_errors/het_loc/phased_size.csv")
    
par_size <- (2781479 - 10001) + (156030895 - 155701383)
pd_size <- read_csv("/net/snowwhite/home/beckandy/research/phasing/output/switch_errors/het_loc/phased_size.csv",show_col_types = FALSE) %>%
  mutate(size_mb = (size - par_size) / 1e6)

df_wh_eagle$size_mb <- pd_size$size_mb
df_wh_beagle$size_mb <- pd_size$size_mb
df_wh_si$size_mb <- pd_size$size_mb
df_vcftools$size_mb <- pd_size$size_mb

df_vcftools$switch_per_mb_beagle <- df_vcftools$n_other_beagle / df_vcftools$size_mb
df_vcftools$switch_per_mb_eagle <- df_vcftools$n_other_eagle / df_vcftools$size_mb
df_vcftools$switch_per_mb_shapeit <- df_vcftools$n_other_shapeit / df_vcftools$size_mb

df_vcftools$flip_per_mb_beagle <- df_vcftools$n_flip_beagle / df_vcftools$size_mb
df_vcftools$flip_per_mb_eagle <- df_vcftools$n_flip_eagle / df_vcftools$size_mb
df_vcftools$flip_per_mb_shapeit <- df_vcftools$n_flip_shapeit / df_vcftools$size_mb

df_vcftools$n_total_beagle <- df_vcftools$n_other_beagle + df_vcftools$n_flip_beagle
df_vcftools$n_total_eagle <- df_vcftools$n_other_eagle + df_vcftools$n_flip_eagle
df_vcftools$n_total_shapeit <- df_vcftools$n_other_shapeit + df_vcftools$n_flip_shapeit

df_vcftools$total_per_mb_beagle <- df_vcftools$n_total_beagle / df_vcftools$size_mb
df_vcftools$total_per_mb_eagle <- df_vcftools$n_total_eagle / df_vcftools$size_mb
df_vcftools$total_per_mb_shapeit <- df_vcftools$n_total_shapeit / df_vcftools$size_mb
```

## Initial Results

We first look at the average counts for each type of error (flips and non-flip switches) for each method within each of the five 1kGP super-populations:

```{r}
df_vcftools %>%
  group_by(pop) %>%
  summarise(mean_switch_eagle = mean(n_other_eagle),
            mean_switch_beagle = mean(n_other_beagle),
            mean_switch_shapeit = mean(n_other_shapeit),
            mean_flip_eagle = mean(n_flip_eagle),
            mean_flip_beagle = mean(n_flip_beagle),
            mean_flip_shapeit = mean(n_flip_shapeit)) %>%
  reactable()
```

We see that in all populations, Eagle has a higher mean number of switch errors per synthetic diploid than Beagle, which in turn has a higner number of switch errors per synthetic diploid than SHAPEIT. In contrast, SHAPEIT has a higher average number of flip errors per synthetic diploid than the other two methods. Below we report the same metrics, but on a per-MB scale:

```{r}
df_vcftools %>%
  group_by(pop) %>%
  summarize(mean_switch_eagle = mean(n_other_eagle / size_mb),
            mean_switch_beagle = mean(n_other_beagle / size_mb),
            mean_switch_shapeit = mean(n_other_shapeit / size_mb),
            mean_flip_eagle = mean(n_flip_eagle / size_mb),
            mean_flip_beagle = mean(n_flip_beagle / size_mb),
            mean_flip_shapeit = mean(n_flip_shapeit / size_mb)) %>%
  reactable()
```

On a per-MB scale, we see the highest rate of switches per MB is observed in the EAS super-population across all three methods, while the lowest switch-error rate is observed in the AMR super-population. The AMR super-population consists of samples from 6 North American admixed samples. For flips, the highest rate of flips per MB for Eagle and Beagle are seen in the EAS super-population as well, while the highest observed rate for SHAPEIT is in the AFR super-population. The correlations of the flip and switch rates are presented below:

```{r}
df_vcftools %>%
  group_by(pop) %>%
  summarize(mean_switch_eagle = mean(n_other_eagle / size_mb),
            mean_switch_beagle = mean(n_other_beagle / size_mb),
            mean_switch_shapeit = mean(n_other_shapeit / size_mb)) %>%
  corrr::correlate(diagonal = 1, method = "pearson") %>%
  reactable()

df_vcftools %>%
  group_by(pop) %>%
  summarize(mean_switch_eagle = mean(n_other_eagle / size_mb),
            mean_switch_beagle = mean(n_other_beagle / size_mb),
            mean_switch_shapeit = mean(n_other_shapeit / size_mb)) %>%
  corrr::correlate(diagonal = 1, method = "spearman") %>%
  reactable()

df_vcftools %>%
  group_by(pop) %>%
  summarize(mean_flip_eagle = mean(n_flip_eagle / size_mb),
            mean_flip_beagle = mean(n_flip_beagle / size_mb),
            mean_flip_shapeit = mean(n_flip_shapeit / size_mb)) %>%
  corrr::correlate(diagonal = 1, method = "pearson") %>%
  reactable()

df_vcftools %>%
  group_by(pop) %>%
  summarize(mean_flip_eagle = mean(n_flip_eagle / size_mb),
            mean_flip_beagle = mean(n_flip_beagle / size_mb),
            mean_flip_shapeit = mean(n_flip_shapeit / size_mb)) %>%
  corrr::correlate(diagonal = 1, method = "spearman") %>%
  reactable()
```

A similar metric is the mean number of heterozygous positions in-between each error. These can be thought of as "trials" at which an error could have occured but did not. Note that this isn't quite right, as we consider each error type independently and are counting the number of heterozygoud positions between errors of each type that are not themselves locations of errors of that type.

```{r}
df_vcftools %>%
  group_by(pop) %>%
  summarize(mean_het_switch_beagle = mean(mean_hets_switch_beagle),
            mean_het_switch_eagle = mean(mean_hets_switch_eagle),
            mean_het_switch_shapeit = mean(mean_hets_switch_shapeit)) %>%
  reactable()
```

The above table does not account for differences in the mean number of heterozygous positions within each synthethic diploid across the populations:

```{r}
df_vcftools %>%
  group_by(pop) %>%
  summarize(mean_n_het = mean(n_hets),
            sd_n_het = sd(n_hets)) %>%
  reactable()
```

### Plots

Here we plot the count of errors within each synthetic diploid between each pair of methods.

#### Total Errors

```{r}
p1 <- scatterplot(df_vcftools, "n_total_beagle", "n_total_eagle", "pop", "Beagle", "Eagle") + labs(colour="Population")

legend_obj <- cowplot::get_legend(p1)
p1 <- p1 + guides(colour = "none")

p2 <- scatterplot(df_vcftools, "n_total_beagle", "n_total_shapeit", "pop", "Beagle", "SHAPEIT") + 
  guides(colour="none") 
p3 <- scatterplot(df_vcftools, "n_total_eagle", "n_total_shapeit", "pop",  "Eagle", "SHAPEIT") + 
  guides(colour="none") 

gridExtra::grid.arrange(p2, p3, p1, legend_obj, layout_matrix = matrix(c(1, 2, 3, 4), byrow = TRUE, ncol = 2))
```

#### Switches

```{r}
p1 <- scatterplot(df_vcftools, "n_other_beagle", "n_other_eagle", "pop", "Beagle", "Eagle") + labs(colour="Population")

legend_obj <- cowplot::get_legend(p1)
p1 <- p1 + guides(colour = "none")

p2 <- scatterplot(df_vcftools, "n_other_beagle", "n_other_shapeit", "pop", "Beagle", "SHAPEIT") + 
  guides(colour="none") 
p3 <- scatterplot(df_vcftools, "n_other_eagle", "n_other_shapeit", "pop",  "Eagle", "SHAPEIT") + 
  guides(colour="none") 

gridExtra::grid.arrange(p2, p3, p1, legend_obj, layout_matrix = matrix(c(1, 2, 3, 4), byrow = TRUE, ncol = 2))
```

#### Flips

```{r}
p1 <- scatterplot(df_vcftools, "n_flip_beagle", "n_flip_eagle", "pop", "Beagle", "Eagle") + labs(colour="Population")

legend_obj <- cowplot::get_legend(p1)
p1 <- p1 + guides(colour = "none")

p2 <- scatterplot(df_vcftools, "n_flip_beagle", "n_flip_shapeit", "pop", "Beagle", "SHAPEIT") + 
  guides(colour="none") 
p3 <- scatterplot(df_vcftools, "n_flip_eagle", "n_flip_shapeit", "pop",  "Eagle", "SHAPEIT") + 
  guides(colour="none") 

gridExtra::grid.arrange(p2, p3, p1, legend_obj, layout_matrix = matrix(c(1, 2, 3, 4), byrow = TRUE, ncol = 2))
```

## Re-writing the draft

We simulate synthetic diploids with known phase by sampling male X chromosomes from the 1kGP study. Each synthetic diploid is statistically phased with a reference panel consisting of the 1kGP samples which were not used to construct the synthetic diploid, and the results of the three phasing methods are compared to the true phase to assess their accuracy. Switches and flips are tallied within each synthetic diploid, and these counts form the basis of our evaluation of the performance of the three methods. Additionally, we evaluate the overlap of errors across methods by identifying shared switch and flip errors. The genomic context in which the errors occur is also evaluated by contrasting the density of errors across the X chromosome with genomic features including GC content and recombination rate.

### The distribution of errors across methods

#### Total Errors

```{r}
df_vcftools %>%
  rowwise() %>%
  mutate(delta_beagle_eagle = n_total_beagle - n_total_eagle,
         delta_beagle_shapeit = n_total_beagle - n_total_shapeit,
         delta_eagle_shapeit = n_total_eagle - n_total_shapeit,
         e_big_b = n_total_eagle > n_total_beagle,
         b_big_s =n_total_beagle > n_total_shapeit,
         s_big_b =n_total_shapeit > n_total_beagle,
         e_big_s = n_total_eagle > n_total_shapeit) %>%
  select(starts_with("delta"),contains("_big_")) %>%
  gtsummary::tbl_summary(statistic = list(all_continuous() ~ "{mean} ({sd})"),
                         digits = list(all_continuous() ~ c(1,2))) %>% 
  gtsummary::as_gt()

df_vcftools %>%
  mutate(delta_beagle_eagle = n_total_beagle - n_total_eagle,
         delta_beagle_shapeit = n_total_beagle - n_total_shapeit,
         delta_eagle_shapeit = n_total_eagle - n_total_shapeit) %>%
  select(pop, starts_with("delta")) %>%
  gtsummary::tbl_summary(by=pop) %>% #gtsummary::tbl_summary(by=pop, statistic = list(all_continuous() ~ "{mean} ({sd})")) %>%
  gtsummary::as_gt()
```

Considering the total number of errors observed within each synthetic diploid, we find that Eagle tends to introduce more errors than both Beagle and SHAPEIT. On average, Eagle produces 39 more errors ($\sigma=20.38$) per synthetic diploid than Beagle, and 35.5 ($\sigma=20.60$) more errors than SHAPEIT. Across the 700 synthetic diploids, in 694 we observe more errors in Eagle than in Beagle, and similarly we observe more errors in Eagle than in SHAPEIT in 683 synthetic diploids. The distributions of total errors between Beagle and SHAPEIT are more similar, with Beagle producing on average 3.6 ($\sigma=14.38$) more errors per synthetic diploid than SHAPEIT, while SHAPEIT introduces more total errors in 414 of the synthetic diploids while Beagle introduces more errors in 266 of the synthetic diploids.

```{r}
df_vcftools %>%
  mutate(delta_beagle_eagle = n_other_beagle - n_other_eagle,
         delta_beagle_shapeit = n_other_beagle - n_other_shapeit,
         delta_eagle_shapeit = n_other_eagle - n_other_shapeit,
         e_big_b = n_other_eagle > n_other_beagle,
         b_big_e = n_other_eagle < n_other_beagle,
         b_big_s =n_other_beagle > n_other_shapeit,
         s_big_b =n_other_shapeit > n_other_beagle,
         e_big_s = n_other_eagle > n_other_shapeit,
         s_big_e = n_other_eagle < n_other_shapeit) %>%
  select(starts_with("delta"),contains("_big_")) %>%
  gtsummary::tbl_summary(statistic = list(all_continuous() ~ "{mean} ({sd})"),
                         digits = list(all_continuous() ~ c(1,2))) %>% 
  gtsummary::as_gt()

df_vcftools %>%
  select(starts_with("n_other")) %>%
   gtsummary::tbl_summary(statistic = list(all_continuous() ~ "{mean} ({sd})"),
                         digits = list(all_continuous() ~ c(1,2)))

df_vcftools %>%
  select(starts_with("n_other"), pop) %>%
   gtsummary::tbl_summary(by = pop,
                          statistic = list(all_continuous() ~ "{mean} ({sd})"),
                         digits = list(all_continuous() ~ c(1,2))) 
```

When we consider non-flip switches separately from flips, we find a similar pattern emerges as that seen with the counts of all errors. Eagle on average produces 39.3 ($\sigma-17.06$) more switches per synthetic diploid than Beagle, and 48.7 ($\sigma=18.79$) more switches per synthetic diploid than SHAPEIT.
